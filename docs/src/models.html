<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.models API documentation</title>
<meta name="description" content="This file contains two classes, the first containing all the information
about the modelisation of a given wire (pertinent axis, spatial extension
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.models</code></h1>
</header>
<section id="section-intro">
<p>This file contains two classes, the first containing all the information
about the modelisation of a given wire (pertinent axis, spatial extension and
parameters of the catenary curve).
The seconds enables to create objects of the first one, and also enables to plot
the point cloud and its model.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This file contains two classes, the first containing all the information
about the modelisation of a given wire (pertinent axis, spatial extension and
parameters of the catenary curve).
The seconds enables to create objects of the first one, and also enables to plot
the point cloud and its model.&#34;&#34;&#34;

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import curve_fit
from math import cosh
from src.Clusters import Clusters
from src.Data import Point

def catenary_curve(x:float|int,x_0:float|int,y_0:float|int,c:float|int):
    &#34;&#34;&#34;
    Gives the value of the catenary function with parameters
    ### Parameters
    :param scalar x : the variable
    :param scalars x_0,y_0,c : parameters of the catenary function 
    :return: a tuple
    &#34;&#34;&#34;
    if type(x) in [int,float,np.float64]:
        return(y_0+c*(cosh((x-x_0)/c)-1))
    else:
        y=[]
        for x_i in x:
            y.append(y_0+c*(cosh((x_i-x_0)/c)-1))
        return y

class _3D_CatenaryCurve():
        
    def __init__(
            self,horizontal_vector:np.ndarray,
            normal_vector:np.ndarray,
            vertical_vector:np.ndarray,
            min_horiz:float,max_horiz:float,
            normal_value_:float, parameters_:tuple
                ):
        self.basis=(horizontal_vector,normal_vector,vertical_vector)
        self.horizontal_values=(min_horiz,max_horiz)
        self.normal_value=normal_value_
        self.parameters=parameters_
    
    def generate_points(self,nb_points:int=100):
        &#34;&#34;&#34;
        Create arrays containing well-distributed points along the
        curve defined in the class
        ### Parameters
        :param int nb_points : number of points we want to generate
        :return : 3 arrays corresponding to the coordinates in the
        canonical basis
        &#34;&#34;&#34;
        horizontal_values=np.linspace(self.horizontal_values[0],self.horizontal_values[1],
                                      nb_points)
        normal_values=np.array([self.normal_value]*nb_points)
        x_0,y_0,c=self.parameters
        vertical_values=catenary_curve(horizontal_values,x_0,y_0,c)

        x,y,z=[],[],[]

        for i in range(nb_points):
            point=Point((horizontal_values[i],normal_values[i],
                        vertical_values[i]),self.basis)
            point.change_basis([np.identity(3)[0],np.identity(3)[1],np.identity(3)[2]])
            x.append(point.coords[0])
            y.append(point.coords[1])
            z.append(point.coords[2])
        return (x,y,z)
    

class Model(Clusters):

    def __init__(self, data_set: np.ndarray | list | pd.core.frame.DataFrame):
        super().__init__(data_set)
        if not self.clustered:
            self.clustering()
        self.basis=[]
        for cluster in range(self.nb_clusters):
            self.basis.append(self.find_2D_plane(cluster))

        
    def adapted_basis(self):
        &#34;&#34;&#34;
        Put every point of the dataset in an adapted basis
        &#34;&#34;&#34;
        for i in range(self.length):
            self.points[i].change_basis(self.basis[self.clusters[i]])
    
    def modelisation_2D(self,cluster):
        &#34;&#34;&#34;
        Gives the three parameters of the best-fitting caternary curve (x0, y0 and c)
        for the point projected on the horizontal vector and the vertical one.
        ### Parameter
        :param int cluster : the wire we study
        :return: a tuple
        &#34;&#34;&#34;
        self.adapted_basis()
        horizont_axis=[]
        vertic_axis=[]
        for i in range(self.length):
            coords=self.get_point(i).coords
            if self.clusters[i]==cluster:
                horizont_axis.append(coords[0])
                vertic_axis.append(coords[2])
        parameters_=list(curve_fit(catenary_curve,horizont_axis,vertic_axis,[0.,0.,1.])[0])
        print(parameters_)
        return parameters_
    
    def display_2D_graph(self,cluster):
        &#34;&#34;&#34;
        Displays a 2D plot of the projection of the cluster on a well-adapted 
        pane as well as the catenary curve assosiated
        ### Parameter
        :param int cluster : the wire we study
        :return: a plot
        &#34;&#34;&#34;
        self.adapted_basis()
        horizont_axis=[]
        vertic_axis=[]
        for i in range(self.length):
            coords=self.get_point(i).coords
            if self.clusters[i]==cluster:
                horizont_axis.append(coords[0])
                vertic_axis.append(coords[2])
        parameters=self.modelisation_2D(cluster)
        plt.figure()
        plt.scatter(horizont_axis,vertic_axis,c=&#34;blue&#34;)
        horizont_axis_bis=np.linspace(min(horizont_axis),max(horizont_axis),200)
        print(&#34;Parameters : \n&#34;)
        print(&#39;x_0=&#39;,parameters[0])
        print(&#34;z_0=&#34;,parameters[1])
        print(&#34;c=&#34;,parameters[2])
        vertic_axis_bis=[catenary_curve(horizont_axis_bis[i],parameters[0],
                                        parameters[1],parameters[2]) 
                                        for i in range(len(horizont_axis_bis))]
        plt.plot(horizont_axis_bis,vertic_axis_bis,c=&#34;red&#34;,alpha=1.)
        plt.xlabel(&#34;Horizontal axis t&#34;)
        plt.ylabel(&#34;Vertical axis z&#34;)
        plt.title(&#34;Best fitting catenary curve for the wire &#34;+str(cluster))
        plt.show()

    def _mean_normal_value(self,cluster:int):
        &#34;&#34;&#34;
        Enables to get the value of the coordinate from the normal vector, which
        is supposed to be orthogonal to the plane associated to the wire.
        &#34;&#34;&#34;
        self.adapted_basis()
        res=0.
        n=0.
        for i in range(self.length):
            if self.clusters[i]==cluster:
                res+=self.get_point(i).coords[1]
                n+=1.
        return res/max(1.,n)
    
    def modelisation_3D(self,cluster):
        self.adapted_basis()
        horizont_axis=[]
        for i in range(self.length):
            coords=self.get_point(i).coords
            if self.clusters[i]==cluster:
                horizont_axis.append(coords[0])
        return _3D_CatenaryCurve(self.basis[cluster][0],self.basis[cluster][1],
                                 self.basis[cluster][2],min(horizont_axis),
                                 max(horizont_axis),self._mean_normal_value(cluster),
                                 tuple(self.modelisation_2D(cluster)))
    
    def display_3D_graph(self,cluster:int,rotation:tuple=(30,30,30)):
        &#34;&#34;&#34;
        Displays a 3D plot of the projection of the cluster on a well-adapted 
        pane as well as the catenary curve assosiated
        ### Parameter
        :param int cluster : the wire we study
        :return: a plot
        &#34;&#34;&#34;
        
        plt.figure()
        x,y,z=[],[],[]
        for i in range(self.length):
            point=self.get_point(i)
            if self.clusters[i]==cluster:
                point.change_basis(np.identity(3))
                x.append(point.coords[0])
                y.append(point.coords[1])
                z.append(point.coords[2])
        ax = plt.subplot(111, projection=&#39;3d&#39;)
        ax.scatter(x,y,z,color=&#39;blue&#39;,alpha=0.1)
        ax.set_xlabel(&#39;x&#39;)
        ax.set_ylabel(&#39;y&#39;)
        ax.set_zlabel(&#39;z&#39;)
        #ax.view_init(rotation[0],rotation[1],rotation[2])
        plt.title(&#34;Best fitting catenary curve for the wire &#34;+str(cluster))

        model=self.modelisation_3D(cluster)
        coords=model.generate_points(100)
        plt.plot(coords[0],coords[1],coords[2],color=&#34;red&#34;)
        plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.models.catenary_curve"><code class="name flex">
<span>def <span class="ident">catenary_curve</span></span>(<span>x: float | int, x_0: float | int, y_0: float | int, c: float | int)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the value of the catenary function with parameters</p>
<h3 id="parameters">Parameters</h3>
<p>:param scalar x : the variable
:param scalars x_0,y_0,c : parameters of the catenary function
:return: a tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def catenary_curve(x:float|int,x_0:float|int,y_0:float|int,c:float|int):
    &#34;&#34;&#34;
    Gives the value of the catenary function with parameters
    ### Parameters
    :param scalar x : the variable
    :param scalars x_0,y_0,c : parameters of the catenary function 
    :return: a tuple
    &#34;&#34;&#34;
    if type(x) in [int,float,np.float64]:
        return(y_0+c*(cosh((x-x_0)/c)-1))
    else:
        y=[]
        for x_i in x:
            y.append(y_0+c*(cosh((x_i-x_0)/c)-1))
        return y</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.models.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
<span>(</span><span>data_set: numpy.ndarray | list | pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an object associated with a group of points</p>
<h3 id="parameters">Parameters</h3>
<p>:param ArrayLike|Dataframe data_set : initial represention of
the points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Model(Clusters):

    def __init__(self, data_set: np.ndarray | list | pd.core.frame.DataFrame):
        super().__init__(data_set)
        if not self.clustered:
            self.clustering()
        self.basis=[]
        for cluster in range(self.nb_clusters):
            self.basis.append(self.find_2D_plane(cluster))

        
    def adapted_basis(self):
        &#34;&#34;&#34;
        Put every point of the dataset in an adapted basis
        &#34;&#34;&#34;
        for i in range(self.length):
            self.points[i].change_basis(self.basis[self.clusters[i]])
    
    def modelisation_2D(self,cluster):
        &#34;&#34;&#34;
        Gives the three parameters of the best-fitting caternary curve (x0, y0 and c)
        for the point projected on the horizontal vector and the vertical one.
        ### Parameter
        :param int cluster : the wire we study
        :return: a tuple
        &#34;&#34;&#34;
        self.adapted_basis()
        horizont_axis=[]
        vertic_axis=[]
        for i in range(self.length):
            coords=self.get_point(i).coords
            if self.clusters[i]==cluster:
                horizont_axis.append(coords[0])
                vertic_axis.append(coords[2])
        parameters_=list(curve_fit(catenary_curve,horizont_axis,vertic_axis,[0.,0.,1.])[0])
        print(parameters_)
        return parameters_
    
    def display_2D_graph(self,cluster):
        &#34;&#34;&#34;
        Displays a 2D plot of the projection of the cluster on a well-adapted 
        pane as well as the catenary curve assosiated
        ### Parameter
        :param int cluster : the wire we study
        :return: a plot
        &#34;&#34;&#34;
        self.adapted_basis()
        horizont_axis=[]
        vertic_axis=[]
        for i in range(self.length):
            coords=self.get_point(i).coords
            if self.clusters[i]==cluster:
                horizont_axis.append(coords[0])
                vertic_axis.append(coords[2])
        parameters=self.modelisation_2D(cluster)
        plt.figure()
        plt.scatter(horizont_axis,vertic_axis,c=&#34;blue&#34;)
        horizont_axis_bis=np.linspace(min(horizont_axis),max(horizont_axis),200)
        print(&#34;Parameters : \n&#34;)
        print(&#39;x_0=&#39;,parameters[0])
        print(&#34;z_0=&#34;,parameters[1])
        print(&#34;c=&#34;,parameters[2])
        vertic_axis_bis=[catenary_curve(horizont_axis_bis[i],parameters[0],
                                        parameters[1],parameters[2]) 
                                        for i in range(len(horizont_axis_bis))]
        plt.plot(horizont_axis_bis,vertic_axis_bis,c=&#34;red&#34;,alpha=1.)
        plt.xlabel(&#34;Horizontal axis t&#34;)
        plt.ylabel(&#34;Vertical axis z&#34;)
        plt.title(&#34;Best fitting catenary curve for the wire &#34;+str(cluster))
        plt.show()

    def _mean_normal_value(self,cluster:int):
        &#34;&#34;&#34;
        Enables to get the value of the coordinate from the normal vector, which
        is supposed to be orthogonal to the plane associated to the wire.
        &#34;&#34;&#34;
        self.adapted_basis()
        res=0.
        n=0.
        for i in range(self.length):
            if self.clusters[i]==cluster:
                res+=self.get_point(i).coords[1]
                n+=1.
        return res/max(1.,n)
    
    def modelisation_3D(self,cluster):
        self.adapted_basis()
        horizont_axis=[]
        for i in range(self.length):
            coords=self.get_point(i).coords
            if self.clusters[i]==cluster:
                horizont_axis.append(coords[0])
        return _3D_CatenaryCurve(self.basis[cluster][0],self.basis[cluster][1],
                                 self.basis[cluster][2],min(horizont_axis),
                                 max(horizont_axis),self._mean_normal_value(cluster),
                                 tuple(self.modelisation_2D(cluster)))
    
    def display_3D_graph(self,cluster:int,rotation:tuple=(30,30,30)):
        &#34;&#34;&#34;
        Displays a 3D plot of the projection of the cluster on a well-adapted 
        pane as well as the catenary curve assosiated
        ### Parameter
        :param int cluster : the wire we study
        :return: a plot
        &#34;&#34;&#34;
        
        plt.figure()
        x,y,z=[],[],[]
        for i in range(self.length):
            point=self.get_point(i)
            if self.clusters[i]==cluster:
                point.change_basis(np.identity(3))
                x.append(point.coords[0])
                y.append(point.coords[1])
                z.append(point.coords[2])
        ax = plt.subplot(111, projection=&#39;3d&#39;)
        ax.scatter(x,y,z,color=&#39;blue&#39;,alpha=0.1)
        ax.set_xlabel(&#39;x&#39;)
        ax.set_ylabel(&#39;y&#39;)
        ax.set_zlabel(&#39;z&#39;)
        #ax.view_init(rotation[0],rotation[1],rotation[2])
        plt.title(&#34;Best fitting catenary curve for the wire &#34;+str(cluster))

        model=self.modelisation_3D(cluster)
        coords=model.generate_points(100)
        plt.plot(coords[0],coords[1],coords[2],color=&#34;red&#34;)
        plt.show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.Clusters.Clusters" href="Clusters.html#src.Clusters.Clusters">Clusters</a></li>
<li><a title="src.Data.Cloud" href="Data.html#src.Data.Cloud">Cloud</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.models.Model.adapted_basis"><code class="name flex">
<span>def <span class="ident">adapted_basis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Put every point of the dataset in an adapted basis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adapted_basis(self):
    &#34;&#34;&#34;
    Put every point of the dataset in an adapted basis
    &#34;&#34;&#34;
    for i in range(self.length):
        self.points[i].change_basis(self.basis[self.clusters[i]])</code></pre>
</details>
</dd>
<dt id="src.models.Model.display_2D_graph"><code class="name flex">
<span>def <span class="ident">display_2D_graph</span></span>(<span>self, cluster)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a 2D plot of the projection of the cluster on a well-adapted
pane as well as the catenary curve assosiated</p>
<h3 id="parameter">Parameter</h3>
<p>:param int cluster : the wire we study
:return: a plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_2D_graph(self,cluster):
    &#34;&#34;&#34;
    Displays a 2D plot of the projection of the cluster on a well-adapted 
    pane as well as the catenary curve assosiated
    ### Parameter
    :param int cluster : the wire we study
    :return: a plot
    &#34;&#34;&#34;
    self.adapted_basis()
    horizont_axis=[]
    vertic_axis=[]
    for i in range(self.length):
        coords=self.get_point(i).coords
        if self.clusters[i]==cluster:
            horizont_axis.append(coords[0])
            vertic_axis.append(coords[2])
    parameters=self.modelisation_2D(cluster)
    plt.figure()
    plt.scatter(horizont_axis,vertic_axis,c=&#34;blue&#34;)
    horizont_axis_bis=np.linspace(min(horizont_axis),max(horizont_axis),200)
    print(&#34;Parameters : \n&#34;)
    print(&#39;x_0=&#39;,parameters[0])
    print(&#34;z_0=&#34;,parameters[1])
    print(&#34;c=&#34;,parameters[2])
    vertic_axis_bis=[catenary_curve(horizont_axis_bis[i],parameters[0],
                                    parameters[1],parameters[2]) 
                                    for i in range(len(horizont_axis_bis))]
    plt.plot(horizont_axis_bis,vertic_axis_bis,c=&#34;red&#34;,alpha=1.)
    plt.xlabel(&#34;Horizontal axis t&#34;)
    plt.ylabel(&#34;Vertical axis z&#34;)
    plt.title(&#34;Best fitting catenary curve for the wire &#34;+str(cluster))
    plt.show()</code></pre>
</details>
</dd>
<dt id="src.models.Model.display_3D_graph"><code class="name flex">
<span>def <span class="ident">display_3D_graph</span></span>(<span>self, cluster: int, rotation: tuple = (30, 30, 30))</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a 3D plot of the projection of the cluster on a well-adapted
pane as well as the catenary curve assosiated</p>
<h3 id="parameter">Parameter</h3>
<p>:param int cluster : the wire we study
:return: a plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_3D_graph(self,cluster:int,rotation:tuple=(30,30,30)):
    &#34;&#34;&#34;
    Displays a 3D plot of the projection of the cluster on a well-adapted 
    pane as well as the catenary curve assosiated
    ### Parameter
    :param int cluster : the wire we study
    :return: a plot
    &#34;&#34;&#34;
    
    plt.figure()
    x,y,z=[],[],[]
    for i in range(self.length):
        point=self.get_point(i)
        if self.clusters[i]==cluster:
            point.change_basis(np.identity(3))
            x.append(point.coords[0])
            y.append(point.coords[1])
            z.append(point.coords[2])
    ax = plt.subplot(111, projection=&#39;3d&#39;)
    ax.scatter(x,y,z,color=&#39;blue&#39;,alpha=0.1)
    ax.set_xlabel(&#39;x&#39;)
    ax.set_ylabel(&#39;y&#39;)
    ax.set_zlabel(&#39;z&#39;)
    #ax.view_init(rotation[0],rotation[1],rotation[2])
    plt.title(&#34;Best fitting catenary curve for the wire &#34;+str(cluster))

    model=self.modelisation_3D(cluster)
    coords=model.generate_points(100)
    plt.plot(coords[0],coords[1],coords[2],color=&#34;red&#34;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="src.models.Model.modelisation_2D"><code class="name flex">
<span>def <span class="ident">modelisation_2D</span></span>(<span>self, cluster)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the three parameters of the best-fitting caternary curve (x0, y0 and c)
for the point projected on the horizontal vector and the vertical one.</p>
<h3 id="parameter">Parameter</h3>
<p>:param int cluster : the wire we study
:return: a tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modelisation_2D(self,cluster):
    &#34;&#34;&#34;
    Gives the three parameters of the best-fitting caternary curve (x0, y0 and c)
    for the point projected on the horizontal vector and the vertical one.
    ### Parameter
    :param int cluster : the wire we study
    :return: a tuple
    &#34;&#34;&#34;
    self.adapted_basis()
    horizont_axis=[]
    vertic_axis=[]
    for i in range(self.length):
        coords=self.get_point(i).coords
        if self.clusters[i]==cluster:
            horizont_axis.append(coords[0])
            vertic_axis.append(coords[2])
    parameters_=list(curve_fit(catenary_curve,horizont_axis,vertic_axis,[0.,0.,1.])[0])
    print(parameters_)
    return parameters_</code></pre>
</details>
</dd>
<dt id="src.models.Model.modelisation_3D"><code class="name flex">
<span>def <span class="ident">modelisation_3D</span></span>(<span>self, cluster)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modelisation_3D(self,cluster):
    self.adapted_basis()
    horizont_axis=[]
    for i in range(self.length):
        coords=self.get_point(i).coords
        if self.clusters[i]==cluster:
            horizont_axis.append(coords[0])
    return _3D_CatenaryCurve(self.basis[cluster][0],self.basis[cluster][1],
                             self.basis[cluster][2],min(horizont_axis),
                             max(horizont_axis),self._mean_normal_value(cluster),
                             tuple(self.modelisation_2D(cluster)))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.Clusters.Clusters" href="Clusters.html#src.Clusters.Clusters">Clusters</a></b></code>:
<ul class="hlist">
<li><code><a title="src.Clusters.Clusters.add_point" href="Data.html#src.Data.Cloud.add_point">add_point</a></code></li>
<li><code><a title="src.Clusters.Clusters.clustering" href="Clusters.html#src.Clusters.Clusters.clustering">clustering</a></code></li>
<li><code><a title="src.Clusters.Clusters.find_2D_plane" href="Clusters.html#src.Clusters.Clusters.find_2D_plane">find_2D_plane</a></code></li>
<li><code><a title="src.Clusters.Clusters.get_point" href="Data.html#src.Data.Cloud.get_point">get_point</a></code></li>
<li><code><a title="src.Clusters.Clusters.print" href="Clusters.html#src.Clusters.Clusters.print">print</a></code></li>
<li><code><a title="src.Clusters.Clusters.remove_point" href="Data.html#src.Data.Cloud.remove_point">remove_point</a></code></li>
<li><code><a title="src.Clusters.Clusters.what_clusters" href="Clusters.html#src.Clusters.Clusters.what_clusters">what_clusters</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.models.catenary_curve" href="#src.models.catenary_curve">catenary_curve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.models.Model" href="#src.models.Model">Model</a></code></h4>
<ul class="">
<li><code><a title="src.models.Model.adapted_basis" href="#src.models.Model.adapted_basis">adapted_basis</a></code></li>
<li><code><a title="src.models.Model.display_2D_graph" href="#src.models.Model.display_2D_graph">display_2D_graph</a></code></li>
<li><code><a title="src.models.Model.display_3D_graph" href="#src.models.Model.display_3D_graph">display_3D_graph</a></code></li>
<li><code><a title="src.models.Model.modelisation_2D" href="#src.models.Model.modelisation_2D">modelisation_2D</a></code></li>
<li><code><a title="src.models.Model.modelisation_3D" href="#src.models.Model.modelisation_3D">modelisation_3D</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>