<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.Clusters API documentation</title>
<meta name="description" content="This file contains the algorithms enabling us to separe the different clusters.
We implement a Cluster class (inheriting from the Cloud class), which …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Clusters</code></h1>
</header>
<section id="section-intro">
<p>This file contains the algorithms enabling us to separe the different clusters.
We implement a Cluster class (inheriting from the Cloud class), which adds the
notion of clusters and implements a clustering in two parts.
The first clustering algorithm is approximative, and only distinguishs groups of
points that are far away (such as the points in the medium dataset).
The second one uses the fact that the wires are parallel. We can thus realize
a clustering by projecting our points on a well choosen axis.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This file contains the algorithms enabling us to separe the different clusters.
We implement a Cluster class (inheriting from the Cloud class), which adds the
notion of clusters and implements a clustering in two parts.
The first clustering algorithm is approximative, and only distinguishs groups of
points that are far away (such as the points in the medium dataset).
The second one uses the fact that the wires are parallel. We can thus realize
a clustering by projecting our points on a well choosen axis.&#34;&#34;&#34;
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
from src.Data import Cloud

class Clusters(Cloud):

    def __init__(self, data_set: np.ndarray | list | pd.core.frame.DataFrame):
        super().__init__(data_set)
        self.clusters=[-1 for ind in range(self.length)]
        self.nb_clusters=1
        self.clustered=False
    
    def what_clusters(self):
        &#34;&#34;&#34;
        Determines the different indexes of clusters
        &#34;&#34;&#34;
        res=[]
        for i in range(self.length):
            clust=self.clusters[i]
            if not clust in res:
                res.append(clust)
        return res

    def _vertical_clustering(self,eps=2.,min_samples=10):
        &#34;&#34;&#34;
        Realizes at first a rough first clustering (using the DBSCAN algorithm) 
        to split the different groups of wires that are far away from each other 
        (in the case of our datasets, it is only useful for the medium difficulty 
        dataset)
        ### Parameters
        :param float eps (optional) : corresponds to the maximum distance we can 
        allow inside of a cluster
        :param float min_samples (optional) : correspond to the minimum number of 
        points that can form a cluster. Those two default parameters are satisfying 
        enough for this dataset.
        :return: updates the clusters
        &#34;&#34;&#34;
        points=[]
        for ind in range(self.length):
            point=self.get_point(ind)
            points.append(list(point.coords))

        clusters=DBSCAN(eps=eps,min_samples=min_samples).fit(points)
        self.clusters=list(clusters.labels_)
        self.nb_clusters=max(self.clusters)-min(self.clusters)+1

    def clustering(self,eps:float=0.5,min_samples:int=10,
                   eps_bis:float=2.,min_samples_bis:int=10):
        &#34;&#34;&#34;
        Clusters the data from the first rough clustering, using a 
        projection on a well choosen line and the DBSCAN algorithm
        ### Parameters
        :param float eps (optional) : corresponds to the maximum distance we can 
        allow inside of a cluster
        :param float min_samples (optional) : correspond to the minimum number of 
        points that can form a cluster. Those two default parameters are satisfying 
        enough for this dataset.
        :param float eps_bis (optional) : same as eps parameter but for the first
        clustering
        :param float min_samples_bis (optional) : same as min_samples parameter but for the
        first clustering
        :return: updates the clusters of self
        &#34;&#34;&#34;
        self._vertical_clustering(eps_bis,min_samples_bis)
        number_of_vertical_clusters=self.nb_clusters
        clust_to_index=[[] for clust in self.what_clusters()]
        new_clusters=[0 for i in range(self.length)]
        increment_of_cluster_number=0
        for clust in range(number_of_vertical_clusters):
        #First, we figure out the best fitting plane for the whole vertical cluster 
        # (using that all the planes are approximately parallel)
            x,y=[],[]
            for i in range(self.length):
                if self.clusters[i]==clust:
                    clust_to_index[clust].append(i)
                    coordinates=self.get_point(i).coords
                    x.append(coordinates[0])
                    y.append(coordinates[1])
            x=np.array(x)
            y=np.array(y)
            coefficients=np.polyfit(x=x,y=y,deg=1)
            #Then we project the points with a vector normal to the approximated direction
            # of the points
            projections=x*coefficients[0]-y

            #At last we use a clustering algorithm to segregate the different projections
            clusters_i=(DBSCAN(eps=eps,min_samples=min_samples).fit(projections.reshape(-1, 1))).labels_
            for j in range(len(clusters_i)):
                new_clusters[clust_to_index[clust][j]]=clusters_i[j]+increment_of_cluster_number
            increment_of_cluster_number+=max(clusters_i)+1
        self.clusters=new_clusters
        self.nb_clusters=max(new_clusters)-min(new_clusters)+1
        self.clustered=True

    def _find_horizontal_line(self,cluster):
        &#34;&#34;&#34;
        finds the vector associated to the horizontal part of the wire
        ### Parameters
        :param int cluster : corresponds to the cluster we are interested in
        :return: the horizontal vector characterizing the wire and its normal
        &#34;&#34;&#34;
        x,y=[],[]
        for i in range(self.length):
            if self.clusters[i]==cluster:
                coordinates=self.get_point(i).coords
                x.append(coordinates[0])
                y.append(coordinates[1])
        coefficients=list(np.polyfit(x=x,y=y,deg=1))

        normal_vector=np.array([coefficients[0],-1.,0.])/np.linalg.norm(
            np.array([coefficients[0],-1.,0.])
        )
        horizontal_vector=np.array([1.,coefficients[0],0.])/np.linalg.norm(
            np.array([1.,coefficients[0],0.])
        )
        return (normal_vector,horizontal_vector)

    def find_2D_plane(self,cluster,lim_corr : float = 0.5):
        &#34;&#34;&#34;
        Verifies the correlation between the normal axis and the z axis
        to determine wether the z is really the vertical axis or not
        ### Parameters
        :param int cluster : corresponds to the cluster we are interested in
        :param float lim_coor : criteria to know if two coordinates are correlated
        or not
        :return: the horizontal vector, the new normal vector and the new vertical
        vector
        &#34;&#34;&#34;
        normal_vector,horizontal_vector=self._find_horizontal_line(cluster)
        z_=np.array([0.,0.,1.])
        n,z=[],[]
        for i in range(self.length):
            if self.clusters[i]==cluster:
                point=np.array(list(self.get_point(i).coords))
                n.append(np.dot(point,normal_vector))
                z.append(point[2])
        correlations=np.min(np.corrcoef(n,z))
        if correlations &lt; lim_corr:
            return (horizontal_vector,normal_vector,z_)
        else:
            coefficients_2=list(np.polyfit(x=n,y=z,deg=1))
            new_normal_vector=coefficients_2[0]*normal_vector-z_
            new_normal_vector=new_normal_vector/np.linalg.norm(new_normal_vector)
            new_vertical_vector=coefficients_2[0]*z_+normal_vector
            new_vertical_vector=new_vertical_vector/np.linalg.norm(new_vertical_vector)
            print(horizontal_vector,new_normal_vector,new_vertical_vector)
            return(horizontal_vector,new_normal_vector,new_vertical_vector)
    
    def print(self,title:str=&#34;Display of the dataset&#34;,
              rotation:list|np.ndarray|tuple=[30.,30.,30.]):
        &#34;&#34;&#34;
        Displays the dataset
        ### Parameters
        :param str title : title of the plot
        :param Arraylike rotation : contains the angle used to
        display the dataset (if 3-dimensional)
        :return: a plot, with different colors for different clusters
        &#34;&#34;&#34;
        colors=[&#34;red&#34;,&#34;blue&#34;,&#34;green&#34;,&#34;pink&#34;,&#34;cyan&#34;,&#34;purple&#34;,&#34;yellow&#34;]
        match self.points[0].dim:
            case 1: 
                X,Y=[],[]
                for i in range(self.length):
                    pnt=self.get_point(i)
                    X.append(pnt.coords[0])
                    Y.append(0.)
                plt.figure()
                plt.scatter(X,Y)
                plt.xlabel(&#34;x axis&#34;)
            case 2: 
                X,Y=[],[]
                for i in range(self.length):
                    pnt=self.get_point(i)
                    X.append(pnt.coords[0])
                    Y.append(pnt.coords[1])
                plt.figure()
                plt.scatter(X,Y)
                plt.xlabel(&#34;x axis&#34;)
                plt.ylabel(&#34;y axis&#34;)
            case 3: 
                X,Y,Z=[],[],[]
                for i in range(self.length):
                    pnt=self.get_point(i)
                    X.append(pnt.coords[0])
                    Y.append(pnt.coords[1])
                    Z.append(pnt.coords[2])
                plt.figure()
                ax = plt.subplot(111, projection=&#39;3d&#39;)
                plt.scatter(X,Y,Z,
                            color=[colors[self.clusters[i]] for i in range(self.length)])
                ax.set_xlabel(&#39;x&#39;)
                ax.set_ylabel(&#39;y&#39;)
                ax.set_zlabel(&#39;z&#39;)
                ax.view_init(rotation[0],rotation[1],rotation[2])
    plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Clusters.Clusters"><code class="flex name class">
<span>class <span class="ident">Clusters</span></span>
<span>(</span><span>data_set: numpy.ndarray | list | pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an object associated with a group of points</p>
<h3 id="parameters">Parameters</h3>
<p>:param ArrayLike|Dataframe data_set : initial represention of
the points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Clusters(Cloud):

    def __init__(self, data_set: np.ndarray | list | pd.core.frame.DataFrame):
        super().__init__(data_set)
        self.clusters=[-1 for ind in range(self.length)]
        self.nb_clusters=1
        self.clustered=False
    
    def what_clusters(self):
        &#34;&#34;&#34;
        Determines the different indexes of clusters
        &#34;&#34;&#34;
        res=[]
        for i in range(self.length):
            clust=self.clusters[i]
            if not clust in res:
                res.append(clust)
        return res

    def _vertical_clustering(self,eps=2.,min_samples=10):
        &#34;&#34;&#34;
        Realizes at first a rough first clustering (using the DBSCAN algorithm) 
        to split the different groups of wires that are far away from each other 
        (in the case of our datasets, it is only useful for the medium difficulty 
        dataset)
        ### Parameters
        :param float eps (optional) : corresponds to the maximum distance we can 
        allow inside of a cluster
        :param float min_samples (optional) : correspond to the minimum number of 
        points that can form a cluster. Those two default parameters are satisfying 
        enough for this dataset.
        :return: updates the clusters
        &#34;&#34;&#34;
        points=[]
        for ind in range(self.length):
            point=self.get_point(ind)
            points.append(list(point.coords))

        clusters=DBSCAN(eps=eps,min_samples=min_samples).fit(points)
        self.clusters=list(clusters.labels_)
        self.nb_clusters=max(self.clusters)-min(self.clusters)+1

    def clustering(self,eps:float=0.5,min_samples:int=10,
                   eps_bis:float=2.,min_samples_bis:int=10):
        &#34;&#34;&#34;
        Clusters the data from the first rough clustering, using a 
        projection on a well choosen line and the DBSCAN algorithm
        ### Parameters
        :param float eps (optional) : corresponds to the maximum distance we can 
        allow inside of a cluster
        :param float min_samples (optional) : correspond to the minimum number of 
        points that can form a cluster. Those two default parameters are satisfying 
        enough for this dataset.
        :param float eps_bis (optional) : same as eps parameter but for the first
        clustering
        :param float min_samples_bis (optional) : same as min_samples parameter but for the
        first clustering
        :return: updates the clusters of self
        &#34;&#34;&#34;
        self._vertical_clustering(eps_bis,min_samples_bis)
        number_of_vertical_clusters=self.nb_clusters
        clust_to_index=[[] for clust in self.what_clusters()]
        new_clusters=[0 for i in range(self.length)]
        increment_of_cluster_number=0
        for clust in range(number_of_vertical_clusters):
        #First, we figure out the best fitting plane for the whole vertical cluster 
        # (using that all the planes are approximately parallel)
            x,y=[],[]
            for i in range(self.length):
                if self.clusters[i]==clust:
                    clust_to_index[clust].append(i)
                    coordinates=self.get_point(i).coords
                    x.append(coordinates[0])
                    y.append(coordinates[1])
            x=np.array(x)
            y=np.array(y)
            coefficients=np.polyfit(x=x,y=y,deg=1)
            #Then we project the points with a vector normal to the approximated direction
            # of the points
            projections=x*coefficients[0]-y

            #At last we use a clustering algorithm to segregate the different projections
            clusters_i=(DBSCAN(eps=eps,min_samples=min_samples).fit(projections.reshape(-1, 1))).labels_
            for j in range(len(clusters_i)):
                new_clusters[clust_to_index[clust][j]]=clusters_i[j]+increment_of_cluster_number
            increment_of_cluster_number+=max(clusters_i)+1
        self.clusters=new_clusters
        self.nb_clusters=max(new_clusters)-min(new_clusters)+1
        self.clustered=True

    def _find_horizontal_line(self,cluster):
        &#34;&#34;&#34;
        finds the vector associated to the horizontal part of the wire
        ### Parameters
        :param int cluster : corresponds to the cluster we are interested in
        :return: the horizontal vector characterizing the wire and its normal
        &#34;&#34;&#34;
        x,y=[],[]
        for i in range(self.length):
            if self.clusters[i]==cluster:
                coordinates=self.get_point(i).coords
                x.append(coordinates[0])
                y.append(coordinates[1])
        coefficients=list(np.polyfit(x=x,y=y,deg=1))

        normal_vector=np.array([coefficients[0],-1.,0.])/np.linalg.norm(
            np.array([coefficients[0],-1.,0.])
        )
        horizontal_vector=np.array([1.,coefficients[0],0.])/np.linalg.norm(
            np.array([1.,coefficients[0],0.])
        )
        return (normal_vector,horizontal_vector)

    def find_2D_plane(self,cluster,lim_corr : float = 0.5):
        &#34;&#34;&#34;
        Verifies the correlation between the normal axis and the z axis
        to determine wether the z is really the vertical axis or not
        ### Parameters
        :param int cluster : corresponds to the cluster we are interested in
        :param float lim_coor : criteria to know if two coordinates are correlated
        or not
        :return: the horizontal vector, the new normal vector and the new vertical
        vector
        &#34;&#34;&#34;
        normal_vector,horizontal_vector=self._find_horizontal_line(cluster)
        z_=np.array([0.,0.,1.])
        n,z=[],[]
        for i in range(self.length):
            if self.clusters[i]==cluster:
                point=np.array(list(self.get_point(i).coords))
                n.append(np.dot(point,normal_vector))
                z.append(point[2])
        correlations=np.min(np.corrcoef(n,z))
        if correlations &lt; lim_corr:
            return (horizontal_vector,normal_vector,z_)
        else:
            coefficients_2=list(np.polyfit(x=n,y=z,deg=1))
            new_normal_vector=coefficients_2[0]*normal_vector-z_
            new_normal_vector=new_normal_vector/np.linalg.norm(new_normal_vector)
            new_vertical_vector=coefficients_2[0]*z_+normal_vector
            new_vertical_vector=new_vertical_vector/np.linalg.norm(new_vertical_vector)
            print(horizontal_vector,new_normal_vector,new_vertical_vector)
            return(horizontal_vector,new_normal_vector,new_vertical_vector)
    
    def print(self,title:str=&#34;Display of the dataset&#34;,
              rotation:list|np.ndarray|tuple=[30.,30.,30.]):
        &#34;&#34;&#34;
        Displays the dataset
        ### Parameters
        :param str title : title of the plot
        :param Arraylike rotation : contains the angle used to
        display the dataset (if 3-dimensional)
        :return: a plot, with different colors for different clusters
        &#34;&#34;&#34;
        colors=[&#34;red&#34;,&#34;blue&#34;,&#34;green&#34;,&#34;pink&#34;,&#34;cyan&#34;,&#34;purple&#34;,&#34;yellow&#34;]
        match self.points[0].dim:
            case 1: 
                X,Y=[],[]
                for i in range(self.length):
                    pnt=self.get_point(i)
                    X.append(pnt.coords[0])
                    Y.append(0.)
                plt.figure()
                plt.scatter(X,Y)
                plt.xlabel(&#34;x axis&#34;)
            case 2: 
                X,Y=[],[]
                for i in range(self.length):
                    pnt=self.get_point(i)
                    X.append(pnt.coords[0])
                    Y.append(pnt.coords[1])
                plt.figure()
                plt.scatter(X,Y)
                plt.xlabel(&#34;x axis&#34;)
                plt.ylabel(&#34;y axis&#34;)
            case 3: 
                X,Y,Z=[],[],[]
                for i in range(self.length):
                    pnt=self.get_point(i)
                    X.append(pnt.coords[0])
                    Y.append(pnt.coords[1])
                    Z.append(pnt.coords[2])
                plt.figure()
                ax = plt.subplot(111, projection=&#39;3d&#39;)
                plt.scatter(X,Y,Z,
                            color=[colors[self.clusters[i]] for i in range(self.length)])
                ax.set_xlabel(&#39;x&#39;)
                ax.set_ylabel(&#39;y&#39;)
                ax.set_zlabel(&#39;z&#39;)
                ax.view_init(rotation[0],rotation[1],rotation[2])
    plt.show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.Data.Cloud" href="Data.html#src.Data.Cloud">Cloud</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.models.Model" href="models.html#src.models.Model">Model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.Clusters.Clusters.clustering"><code class="name flex">
<span>def <span class="ident">clustering</span></span>(<span>self, eps: float = 0.5, min_samples: int = 10, eps_bis: float = 2.0, min_samples_bis: int = 10)</span>
</code></dt>
<dd>
<div class="desc"><p>Clusters the data from the first rough clustering, using a
projection on a well choosen line and the DBSCAN algorithm</p>
<h3 id="parameters">Parameters</h3>
<p>:param float eps (optional) : corresponds to the maximum distance we can
allow inside of a cluster
:param float min_samples (optional) : correspond to the minimum number of
points that can form a cluster. Those two default parameters are satisfying
enough for this dataset.
:param float eps_bis (optional) : same as eps parameter but for the first
clustering
:param float min_samples_bis (optional) : same as min_samples parameter but for the
first clustering
:return: updates the clusters of self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clustering(self,eps:float=0.5,min_samples:int=10,
               eps_bis:float=2.,min_samples_bis:int=10):
    &#34;&#34;&#34;
    Clusters the data from the first rough clustering, using a 
    projection on a well choosen line and the DBSCAN algorithm
    ### Parameters
    :param float eps (optional) : corresponds to the maximum distance we can 
    allow inside of a cluster
    :param float min_samples (optional) : correspond to the minimum number of 
    points that can form a cluster. Those two default parameters are satisfying 
    enough for this dataset.
    :param float eps_bis (optional) : same as eps parameter but for the first
    clustering
    :param float min_samples_bis (optional) : same as min_samples parameter but for the
    first clustering
    :return: updates the clusters of self
    &#34;&#34;&#34;
    self._vertical_clustering(eps_bis,min_samples_bis)
    number_of_vertical_clusters=self.nb_clusters
    clust_to_index=[[] for clust in self.what_clusters()]
    new_clusters=[0 for i in range(self.length)]
    increment_of_cluster_number=0
    for clust in range(number_of_vertical_clusters):
    #First, we figure out the best fitting plane for the whole vertical cluster 
    # (using that all the planes are approximately parallel)
        x,y=[],[]
        for i in range(self.length):
            if self.clusters[i]==clust:
                clust_to_index[clust].append(i)
                coordinates=self.get_point(i).coords
                x.append(coordinates[0])
                y.append(coordinates[1])
        x=np.array(x)
        y=np.array(y)
        coefficients=np.polyfit(x=x,y=y,deg=1)
        #Then we project the points with a vector normal to the approximated direction
        # of the points
        projections=x*coefficients[0]-y

        #At last we use a clustering algorithm to segregate the different projections
        clusters_i=(DBSCAN(eps=eps,min_samples=min_samples).fit(projections.reshape(-1, 1))).labels_
        for j in range(len(clusters_i)):
            new_clusters[clust_to_index[clust][j]]=clusters_i[j]+increment_of_cluster_number
        increment_of_cluster_number+=max(clusters_i)+1
    self.clusters=new_clusters
    self.nb_clusters=max(new_clusters)-min(new_clusters)+1
    self.clustered=True</code></pre>
</details>
</dd>
<dt id="src.Clusters.Clusters.find_2D_plane"><code class="name flex">
<span>def <span class="ident">find_2D_plane</span></span>(<span>self, cluster, lim_corr: float = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies the correlation between the normal axis and the z axis
to determine wether the z is really the vertical axis or not</p>
<h3 id="parameters">Parameters</h3>
<p>:param int cluster : corresponds to the cluster we are interested in
:param float lim_coor : criteria to know if two coordinates are correlated
or not
:return: the horizontal vector, the new normal vector and the new vertical
vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_2D_plane(self,cluster,lim_corr : float = 0.5):
    &#34;&#34;&#34;
    Verifies the correlation between the normal axis and the z axis
    to determine wether the z is really the vertical axis or not
    ### Parameters
    :param int cluster : corresponds to the cluster we are interested in
    :param float lim_coor : criteria to know if two coordinates are correlated
    or not
    :return: the horizontal vector, the new normal vector and the new vertical
    vector
    &#34;&#34;&#34;
    normal_vector,horizontal_vector=self._find_horizontal_line(cluster)
    z_=np.array([0.,0.,1.])
    n,z=[],[]
    for i in range(self.length):
        if self.clusters[i]==cluster:
            point=np.array(list(self.get_point(i).coords))
            n.append(np.dot(point,normal_vector))
            z.append(point[2])
    correlations=np.min(np.corrcoef(n,z))
    if correlations &lt; lim_corr:
        return (horizontal_vector,normal_vector,z_)
    else:
        coefficients_2=list(np.polyfit(x=n,y=z,deg=1))
        new_normal_vector=coefficients_2[0]*normal_vector-z_
        new_normal_vector=new_normal_vector/np.linalg.norm(new_normal_vector)
        new_vertical_vector=coefficients_2[0]*z_+normal_vector
        new_vertical_vector=new_vertical_vector/np.linalg.norm(new_vertical_vector)
        print(horizontal_vector,new_normal_vector,new_vertical_vector)
        return(horizontal_vector,new_normal_vector,new_vertical_vector)</code></pre>
</details>
</dd>
<dt id="src.Clusters.Clusters.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, title: str = 'Display of the dataset', rotation: list | numpy.ndarray | tuple = [30.0, 30.0, 30.0])</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the dataset</p>
<h3 id="parameters">Parameters</h3>
<p>:param str title : title of the plot
:param Arraylike rotation : contains the angle used to
display the dataset (if 3-dimensional)
:return: a plot, with different colors for different clusters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self,title:str=&#34;Display of the dataset&#34;,
          rotation:list|np.ndarray|tuple=[30.,30.,30.]):
    &#34;&#34;&#34;
    Displays the dataset
    ### Parameters
    :param str title : title of the plot
    :param Arraylike rotation : contains the angle used to
    display the dataset (if 3-dimensional)
    :return: a plot, with different colors for different clusters
    &#34;&#34;&#34;
    colors=[&#34;red&#34;,&#34;blue&#34;,&#34;green&#34;,&#34;pink&#34;,&#34;cyan&#34;,&#34;purple&#34;,&#34;yellow&#34;]
    match self.points[0].dim:
        case 1: 
            X,Y=[],[]
            for i in range(self.length):
                pnt=self.get_point(i)
                X.append(pnt.coords[0])
                Y.append(0.)
            plt.figure()
            plt.scatter(X,Y)
            plt.xlabel(&#34;x axis&#34;)
        case 2: 
            X,Y=[],[]
            for i in range(self.length):
                pnt=self.get_point(i)
                X.append(pnt.coords[0])
                Y.append(pnt.coords[1])
            plt.figure()
            plt.scatter(X,Y)
            plt.xlabel(&#34;x axis&#34;)
            plt.ylabel(&#34;y axis&#34;)
        case 3: 
            X,Y,Z=[],[],[]
            for i in range(self.length):
                pnt=self.get_point(i)
                X.append(pnt.coords[0])
                Y.append(pnt.coords[1])
                Z.append(pnt.coords[2])
            plt.figure()
            ax = plt.subplot(111, projection=&#39;3d&#39;)
            plt.scatter(X,Y,Z,
                        color=[colors[self.clusters[i]] for i in range(self.length)])
            ax.set_xlabel(&#39;x&#39;)
            ax.set_ylabel(&#39;y&#39;)
            ax.set_zlabel(&#39;z&#39;)
            ax.view_init(rotation[0],rotation[1],rotation[2])</code></pre>
</details>
</dd>
<dt id="src.Clusters.Clusters.what_clusters"><code class="name flex">
<span>def <span class="ident">what_clusters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the different indexes of clusters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def what_clusters(self):
    &#34;&#34;&#34;
    Determines the different indexes of clusters
    &#34;&#34;&#34;
    res=[]
    for i in range(self.length):
        clust=self.clusters[i]
        if not clust in res:
            res.append(clust)
    return res</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.Data.Cloud" href="Data.html#src.Data.Cloud">Cloud</a></b></code>:
<ul class="hlist">
<li><code><a title="src.Data.Cloud.add_point" href="Data.html#src.Data.Cloud.add_point">add_point</a></code></li>
<li><code><a title="src.Data.Cloud.get_point" href="Data.html#src.Data.Cloud.get_point">get_point</a></code></li>
<li><code><a title="src.Data.Cloud.remove_point" href="Data.html#src.Data.Cloud.remove_point">remove_point</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Clusters.Clusters" href="#src.Clusters.Clusters">Clusters</a></code></h4>
<ul class="">
<li><code><a title="src.Clusters.Clusters.clustering" href="#src.Clusters.Clusters.clustering">clustering</a></code></li>
<li><code><a title="src.Clusters.Clusters.find_2D_plane" href="#src.Clusters.Clusters.find_2D_plane">find_2D_plane</a></code></li>
<li><code><a title="src.Clusters.Clusters.print" href="#src.Clusters.Clusters.print">print</a></code></li>
<li><code><a title="src.Clusters.Clusters.what_clusters" href="#src.Clusters.Clusters.what_clusters">what_clusters</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>